"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentUpdater = void 0;
const handlers_1 = require("../handlers");
const errors_1 = require("../errors");
const node_events_1 = require("node:events");
const node_path_1 = require("node:path");
const unzipper_1 = require("unzipper");
const node_fs_1 = require("node:fs");
/**
 * A class for updating content.
 * @extends EventEmitter
 */
class ContentUpdater extends node_events_1.EventEmitter {
    options;
    /**
     * The Request handler.
     */
    handler;
    /**
     * Creates a new `ContentUpdater` instance.
     * @param options - The options for the ContentUpdater class.
     * @param options.checkInterval - The interval set to check for updates.
     */
    constructor(options) {
        super();
        this.options = options;
        this.handler = new handlers_1.RequestHandler();
    }
    /**
     * Automatically updates the content at a given interval.
     */
    checkForUpdates() {
        if (this.options?.checkInterval &&
            typeof this.options.checkInterval !== "number") {
            throw new errors_1.PackageError("The interval must be a number in ms");
        }
        if (this.options?.checkInterval && this.options.checkInterval < 20000) {
            throw new errors_1.PackageError("The interval must be longer than 20000 ms (20 seconds)");
        }
        setInterval(async () => {
            try {
                const { lastVersion, zip } = await this.handler.updateInfo();
                const config = JSON.parse((0, node_fs_1.readFileSync)((0, node_path_1.join)(__dirname, "../utils/config.json"), "utf-8"));
                const fPath = (0, node_path_1.join)(__dirname, "../utils");
                const parseVersion = (version) => {
                    return version.split(".").join("");
                };
                if (parseVersion(lastVersion) > parseVersion(config.version)) {
                    await new Promise((resolve) => {
                        const zipPath = (0, node_path_1.join)(fPath, `v${lastVersion}-content.zip`);
                        zip.pipe((0, node_fs_1.createWriteStream)(zipPath));
                        zip.on("end", () => {
                            (0, node_fs_1.createReadStream)(zipPath)
                                .pipe((0, unzipper_1.Extract)({ path: fPath }))
                                .on("close", () => {
                                (0, node_fs_1.rmSync)(zipPath);
                                this.emit("onUpdateSuccess");
                                resolve();
                            });
                        });
                    });
                }
            }
            catch (_) {
                this.emit("onUpdateFail", "Failed to update the version content.");
            }
        }, this.options?.checkInterval || 20000);
    }
    /**
     * Adds an event listener to the `ContentUpdater` instance.
     * @param event - The event to listen for.
     * @param listener - The event listener.
     * @returns The `ContentUpdater` instance.
     */
    on(event, listener) {
        return super.on(event, listener);
    }
    /**
     * Adds an event listener that will be invoked only once to the `ContentUpdater` instance.
     * @param event - The event to listen for.
     * @param listener - The event listener.
     * @returns The `ContentUpdater` instance.
     */
    once(event, listener) {
        return super.once(event, listener);
    }
    /**
     * Emits an event on the `ContentUpdater` instance.
     * @param event - The event to emit.
     * @param args - The arguments to pass to the event listeners.
     * @returns `true` if the event had listeners, `false` otherwise.
     */
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
}
exports.ContentUpdater = ContentUpdater;
