"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheHandler = void 0;
const errors_1 = require("../errors");
const node_path_1 = require("node:path");
const node_crypto_1 = require("node:crypto");
const node_fs_1 = require("node:fs");
/**
 * A class that handles the cache.
 */
class CacheHandler {
    /**
     * Creates a new `CacheHandler` instance.
     */
    constructor() { }
    /**
     * Creates a directory where the cache files get stored if it doesn't exist already.
     */
    setupCacheDirectory() {
        const cacheDirectory = (0, node_path_1.join)(__dirname, "../cache");
        if (!(0, node_fs_1.existsSync)(cacheDirectory)) {
            (0, node_fs_1.mkdir)(cacheDirectory, (err) => {
                if (err)
                    throw new errors_1.PackageError("Failed to setup the cache directory");
            });
        }
    }
    /**
     * Deletes the cache directory.
     */
    deleteCacheDirectory() {
        const cacheDirectory = (0, node_path_1.join)(__dirname, "../cache");
        if ((0, node_fs_1.existsSync)(cacheDirectory)) {
            (0, node_fs_1.rmdir)(cacheDirectory, (err) => {
                if (err)
                    throw new errors_1.PackageError("Failed to delete the cache directory");
            });
        }
    }
    /**
     * Creates a cache file with the given data.
     * @param key - The key to create the hash for the file name.
     * @param value - The value that will be stored in the file.
     */
    set(key, value) {
        const cacheFileName = `${(0, node_crypto_1.createHash)("md5").update(key).digest("hex")}.json`;
        const cacheFilePath = (0, node_path_1.join)(__dirname, `../cache/${cacheFileName}`);
        if (!(0, node_fs_1.existsSync)(cacheFilePath)) {
            (0, node_fs_1.writeFile)(cacheFilePath, JSON.stringify(value, null, 2), (err) => {
                if (err)
                    throw new errors_1.PackageError("Failed to create the cache file.");
            });
        }
    }
    /**
     * Get and retrieve the cached data and deletes the expired and corrupted cache files.
     * @param key - The key to create the hash for the file name.
     * @returns The data of the cache file or undefined if cache file was not found.
     */
    get(key) {
        const cacheFileName = `${(0, node_crypto_1.createHash)("md5").update(key).digest("hex")}.json`;
        const cacheFilePath = (0, node_path_1.join)(__dirname, `../cache/${cacheFileName}`);
        if (!(0, node_fs_1.existsSync)(cacheFilePath))
            return undefined;
        try {
            const data = JSON.parse((0, node_fs_1.readFileSync)(cacheFilePath, "utf-8"));
            const date = new Date();
            date.setSeconds(date.getSeconds() - (data?.ttl || 60));
            const fileTime = (0, node_fs_1.statSync)(cacheFilePath).mtime;
            if (date > fileTime) {
                (0, node_fs_1.unlink)(cacheFilePath, (err) => {
                    if (err)
                        throw new errors_1.PackageError("Failed to delete the expired cache file.");
                });
                return undefined;
            }
            return data;
        }
        catch (_) {
            (0, node_fs_1.unlink)(cacheFilePath, (err) => {
                if (err)
                    throw new errors_1.PackageError("Failed to delete the corrupted cache file.");
            });
            return undefined;
        }
    }
}
exports.CacheHandler = CacheHandler;
